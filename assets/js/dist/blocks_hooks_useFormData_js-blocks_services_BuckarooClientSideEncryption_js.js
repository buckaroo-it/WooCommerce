"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["blocks_hooks_useFormData_js-blocks_services_BuckarooClientSideEncryption_js"],{

/***/ "./blocks/hooks/useFormData.js":
/*!*************************************!*\
  !*** ./blocks/hooks/useFormData.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\nvar useFormData = function useFormData(initialState, onStateChange) {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialState),\n    _useState2 = _slicedToArray(_useState, 2),\n    formState = _useState2[0],\n    setFormState = _useState2[1];\n  var handleChange = function handleChange(e) {\n    var _e$target = e.target,\n      name = _e$target.name,\n      value = _e$target.value;\n    var updatedState = _objectSpread(_objectSpread({}, formState), {}, _defineProperty({}, name, value));\n    setFormState(updatedState);\n    onStateChange(updatedState);\n  };\n  var updateFormState = function updateFormState(fieldName, value) {\n    var updatedState = _objectSpread(_objectSpread({}, formState), {}, _defineProperty({}, fieldName, value));\n    setFormState(updatedState);\n    onStateChange(updatedState);\n  };\n  return {\n    formState: formState,\n    handleChange: handleChange,\n    updateFormState: updateFormState\n  };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useFormData);\n\n//# sourceURL=webpack:///./blocks/hooks/useFormData.js?");

/***/ }),

/***/ "./blocks/services/BuckarooClientSideEncryption.js":
/*!*********************************************************!*\
  !*** ./blocks/services/BuckarooClientSideEncryption.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _checkout_creditcard_encryption_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../checkout/creditcard-encryption-sdk */ \"./checkout/creditcard-encryption-sdk.js\");\n\nvar encryptCardData = function encryptCardData(cardDetails) {\n  var cardNumber = cardDetails.cardNumber,\n    cardYear = cardDetails.cardYear,\n    cardMonth = cardDetails.cardMonth,\n    cardCVC = cardDetails.cardCVC,\n    cardName = cardDetails.cardName;\n  var validator = _checkout_creditcard_encryption_sdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].V001;\n  return new Promise(function (resolve) {\n    if (validator.validateCardNumber(cardNumber) && validator.validateCvc(cardCVC) && validator.validateCardholderName(cardName) && validator.validateYear(cardYear) && validator.validateMonth(cardMonth)) {\n      _checkout_creditcard_encryption_sdk__WEBPACK_IMPORTED_MODULE_0__[\"default\"].V001.encryptCardData(cardNumber, cardYear, cardMonth, cardCVC, cardName, function (encryptedCardData) {\n        resolve(encryptedCardData);\n      });\n    }\n  });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encryptCardData);\n\n//# sourceURL=webpack:///./blocks/services/BuckarooClientSideEncryption.js?");

/***/ }),

/***/ "./checkout/creditcard-encryption-sdk.js":
/*!***********************************************!*\
  !*** ./checkout/creditcard-encryption-sdk.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\r\n * Buckaroo Client Side Encryption v1.0.0\r\n *\r\n * Copyright Buckaroo\r\n * Released under the MIT license\r\n * https://buckaroo.nl\r\n *\r\n * Date: 2018-10-18 09:26\r\n */\nvar BuckarooClientSideEncryption;\n(function (BuckarooClientSideEncryption) {\n  var V001;\n  (function (V001) {\n    var isNullOrWhitespace = function isNullOrWhitespace(input) {\n      if (typeof input === 'undefined' || input === null) {\n        return true;\n      }\n      return input.replace(/\\s/g, '').length < 1;\n    };\n    V001.validateCardNumber = function (cardNumberString, cardService) {\n      if (typeof cardNumberString === 'undefined' || cardNumberString === null) {\n        return false;\n      }\n      // Accept only digits.\n      if (/[^0-9]+/.test(cardNumberString)) {\n        return false;\n      }\n      // Accept only card numbers with a length between 10 and 19.\n      if (cardNumberString.length < 10 || cardNumberString.length > 19) {\n        return false;\n      }\n      // The Luhn Algorithm.\n      var sum = 0;\n      for (var i = 0; i < cardNumberString.length; i++) {\n        var digit = parseInt(cardNumberString.charAt(i), 10);\n        if (i % 2 === cardNumberString.length % 2) {\n          digit *= 2;\n          if (digit > 9) {\n            digit -= 9;\n          }\n        }\n        sum += digit;\n      }\n      if (sum % 10 !== 0) {\n        return false;\n      }\n      if (typeof cardService === 'undefined' || cardService === null) {\n        // We could not determine the card service, so we don't know how the card number should be formatted, so return true.\n        return true;\n      }\n      switch (cardService.toLowerCase()) {\n        case 'visa':\n        case 'visaelectron':\n        case 'vpay':\n        case 'cartebleuevisa':\n        case 'dankort':\n          return /^4[0-9]{12}(?:[0-9]{3})?$/.test(cardNumberString);\n        case 'postepay':\n        case 'mastercard':\n          return /^(5[1-5]|2[2-7])[0-9]{14}$/.test(cardNumberString);\n        case 'bancontactmrcash':\n        case 'bancontact':\n          return /^(4796|6060|6703|5613|5614)[0-9]{12,15}$/.test(cardNumberString);\n        case 'maestro':\n          return /^\\d{12,19}$/.test(cardNumberString);\n        case 'amex':\n        case 'americanexpress':\n          return /^3[47][0-9]{13}$/.test(cardNumberString);\n        case 'cartebancaire':\n        case 'cartasi':\n          return /^((5[1-5]|2[2-7])[0-9]{14})|(4[0-9]{12}(?:[0-9]{3})?)$/.test(cardNumberString);\n        default:\n          // Not a card service Buckaroo recognizes, so return false.\n          return false;\n      }\n    };\n    V001.validateCvc = function (cvcString, cardService) {\n      if (typeof cvcString === 'undefined' || cvcString === null) {\n        return false;\n      }\n      // Determine if the cvc has the correct length.\n      if (typeof cardService === 'undefined' || cardService === null) {\n        // We do not know the card service, so accept cvc length of 0, 3, or 4.\n        if (cvcString.length === 0) {\n          return true;\n        }\n        if (cvcString.length !== 3 && cvcString.length !== 4) {\n          return false;\n        }\n      } else {\n        switch (cardService.toLowerCase()) {\n          case 'bancontactmrcash':\n          case 'bancontact':\n          case 'maestro':\n            // These card services does not use a cvc so no cvc should be set.\n            return cvcString.length === 0;\n          case 'amex':\n          case 'americanexpress':\n            // American Express uses a cvc with 4 digits.\n            if (cvcString.length !== 4) {\n              return false;\n            }\n            break;\n          default:\n            // All other card services uses cvc with 3 digits.\n            if (cvcString.length !== 3) {\n              return false;\n            }\n            break;\n        }\n      }\n      // Accept only digits\n      if (/[^0-9]+/.test(cvcString)) {\n        return false;\n      }\n      return true;\n    };\n    V001.validateYear = function (yearString) {\n      if (typeof yearString === 'undefined' || yearString === null) {\n        return false;\n      }\n      // Accept only digits.\n      if (/[^0-9]+/.test(yearString)) {\n        return false;\n      }\n      // Only years with a length of 2 or 4 are accepted.\n      if (yearString.length !== 2 && yearString.length !== 4) {\n        return false;\n      }\n      return true;\n    };\n    V001.validateMonth = function (monthString) {\n      if (typeof monthString === 'undefined' || monthString === null) {\n        return false;\n      }\n      // Accept only digits.\n      if (/[^0-9]+/.test(monthString)) {\n        return false;\n      }\n      // Only months with a length of 1 or 2 are accepted.\n      if (monthString.length !== 1 && monthString.length !== 2) {\n        return false;\n      }\n      // Check the value of month, it should be between 1 and 12.\n      var monthInt = parseInt(monthString);\n      if (monthInt < 1 || monthInt > 12) {\n        return false;\n      }\n      return true;\n    };\n    V001.validateCardholderName = function (nameString) {\n      if (typeof nameString === 'undefined' || nameString === null) {\n        return false;\n      }\n      // Cardholder name should be filled.\n      return !isNullOrWhitespace(nameString);\n    };\n    // Values to use in the encryption process.\n    var Variables;\n    (function (Variables) {\n      Variables.algorithm = 'RSA-OAEP';\n      Variables.hashName = 'SHA-1';\n      Variables.exponent = 'AQAB';\n      Variables.keyType = 'RSA';\n      Variables.modulus = '4NdLa7WIq-ygcTo4tGFu8ec7qRwtZ1jLEjKntXfs56gaWtaYSxc-er7ljG22rbv41T5raYfdzvPqV3YcTFCOLpdJIJkzTvorY-IDR09kN6uHKGutSjdkDpYrKFHeU_x0W7P0GUW2Sc14B7G_L8C2eMSqkDAMtANyvOCHdk_2chYOgYqIuZfInTaNEzHbYb6i-D5sKeu1D15G2uEFY-gkuLmtDq3xPUzK_G-haG4KsIL5JKbt-kV3_Dibu3OUpiMDN1YpocqaUR5soFmKiJi1PHtgQZ0aydXxveHIRhtE-5FgL7w307gOqbMJ4q3fXDAZQzKBwlNYnwgAaFW1PSzk9w';\n      Variables.version = '001';\n      Variables.keyFormat = 'jwk';\n      Variables.keyOperations = ['encrypt'];\n      Variables.publicKeyData = {\n        alg: Variables.algorithm,\n        e: Variables.exponent,\n        ext: true,\n        kty: Variables.keyType,\n        n: Variables.modulus\n      };\n      Variables.algorithmParams = {\n        name: Variables.algorithm,\n        hash: {\n          name: Variables.hashName\n        }\n      };\n    })(Variables || (Variables = {}));\n    // Encodes an Uint8 array to a Base64 string.\n    var base64EncodeUint8Array = function base64EncodeUint8Array(uint8Array) {\n      return btoa(String.fromCharCode.apply(null, uint8Array));\n    };\n    // Decodes a Base64 string to an Uint8 array.\n    var base64Decode = function base64Decode(base64String) {\n      return atob(base64String).split('').map(function (c) {\n        return c.charCodeAt(0);\n      });\n    };\n    // Creates an Uint8Array of the given card data\n    var cardDataToUint8Array = function cardDataToUint8Array(cardNumber, year, month, cvc, cardholder) {\n      var encryptableString = \"\".concat(cardNumber, \",\").concat(year, \",\").concat(month, \",\").concat(cvc, \",\").concat(cardholder);\n      var encryptableUtf8String = unescape(encodeURIComponent(encryptableString));\n      var encryptableArray = [];\n      for (var i = 0; i < encryptableUtf8String.length; i++) {\n        encryptableArray.push(encryptableUtf8String.charCodeAt(i));\n      }\n      return new Uint8Array(encryptableArray);\n    };\n    // Is the current browser Internet Explorer?\n    var isBrowserInternetExplorer = function isBrowserInternetExplorer() {\n      var ua = window.navigator.userAgent;\n      var msie = ua.indexOf('MSIE ');\n      return msie > 0 || !!navigator.userAgent.match(/Trident.*rv\\:11\\./);\n    };\n    // Returns a promise whose result is the base64-encoded encrypted card data, decryptable only by Buckaroo.\n    //\n    // Usage:\n    // All parameter values are strings\n    //\n    V001.encryptCardDataOther = function (cardNumber, year, month, cvc, cardholder) {\n      // Create an encryptable Uint8 array from the input, which will be encrypted.\n      var encryptableUint8Array = cardDataToUint8Array(cardNumber, year, month, cvc, cardholder);\n      return window.crypto.subtle.importKey(Variables.keyFormat, Variables.publicKeyData, Variables.algorithmParams, true, Variables.keyOperations)\n      // Then, encrypt the input data\n      .then(function (publicKey) {\n        return window.crypto.subtle.encrypt(Variables.algorithmParams, publicKey, encryptableUint8Array.buffer)\n        // Then, encode the encrypted data to Base64 and prepend the encryption version\n        .then(function (encryptedBuffer) {\n          var encryptedUint8Array = new Uint8Array(encryptedBuffer);\n          var encryptedBase64String = base64EncodeUint8Array(encryptedUint8Array);\n          return Variables.version + encryptedBase64String;\n        }, function (error) {\n          console.log(error);\n        });\n      }, function (error) {\n        console.log(error);\n      });\n    };\n    // Because Internet Explorer does not support JavaScript Promises, an Internet Explorer specific encrypt card data function is provided.\n    //\n    // Usage:\n    V001.encryptCardDataIE = function (cardNumber, year, month, cvc, cardholder, callback) {\n      var crypto = window.crypto || window.msCrypto;\n      var cryptoSubtle = crypto.subtle;\n      // Create an encryptable Uint8 array from the input, which will be encrypted.\n      var encryptableUint8Array = cardDataToUint8Array(cardNumber, year, month, cvc, cardholder);\n      // Get the public key data\n      var key = {\n        publicKey: \"{ \\t\\t\\t\\t\\t\\\"kty\\\" : \\\"\".concat(Variables.keyType, \"\\\", \\t\\t\\t\\t\\t\\\"extractable\\\" : true, \\t\\t\\t\\t\\t\\\"n\\\" : \\\"\").concat(Variables.modulus, \"\\\", \\t\\t\\t\\t\\t\\\"e\\\" : \\\"\").concat(Variables.exponent, \"\\\", \\t\\t\\t\\t\\t\\\"alg\\\" : \\\"\").concat(Variables.algorithm, \"\\\" \\t\\t\\t\\t}\")\n      };\n      var keyArray = new Uint8Array(key.publicKey.length);\n      for (var i = 0; i < key.publicKey.length; i += 1) {\n        keyArray[i] = key.publicKey.charCodeAt(i);\n      }\n      // Import the public key\n      var importOperation = cryptoSubtle.importKey(Variables.keyFormat, keyArray, Variables.algorithmParams, true, Variables.keyOperations);\n      importOperation.onerror = function (error) {\n        console.error(error);\n      };\n      // When the public key is successfully imported, encrypt the card data\n      importOperation.oncomplete = function (event) {\n        var publicKey = event.target.result;\n        var encryptOperation = cryptoSubtle.encrypt(Variables.algorithmParams, publicKey, encryptableUint8Array.buffer);\n        encryptOperation.onerror = function (error) {\n          console.error(error);\n        };\n        // When the card data is successfully encrypted, perform the callback function with the encrypted card data\n        encryptOperation.oncomplete = function (e) {\n          var encryptedUint8Array = new Uint8Array(e.target.result);\n          var encryptedBase64String = base64EncodeUint8Array(encryptedUint8Array);\n          var encryptedCardData = Variables.version + encryptedBase64String;\n          callback(encryptedCardData);\n        };\n      };\n    };\n    V001.encryptCardData = function (cardNumber, year, month, cvc, cardholder, callback) {\n      if (isBrowserInternetExplorer()) {\n        V001.encryptCardDataIE(cardNumber, year, month, cvc, cardholder, callback);\n      } else {\n        V001.encryptCardDataOther(cardNumber, year, month, cvc, cardholder).then(function (encryptedCardData) {\n          callback(encryptedCardData);\n        }, function (error) {\n          console.log(error);\n        });\n      }\n    };\n  })(V001 = BuckarooClientSideEncryption.V001 || (BuckarooClientSideEncryption.V001 = {}));\n})(BuckarooClientSideEncryption || (BuckarooClientSideEncryption = {}));\n// sourceMappingURL=ClientSideEncryption001.js.map\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BuckarooClientSideEncryption);\n\n//# sourceURL=webpack:///./checkout/creditcard-encryption-sdk.js?");

/***/ })

}]);